package browser

import (
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"strings"

	"github.com/user/ghost-browser/internal/fingerprint"
)

// GenerateSpoofScript creates the JavaScript injection script
func GenerateSpoofScript(fp *fingerprint.Fingerprint) string {
	noiseSeed := generateNoiseSeed()
	languagesJS := formatLanguagesJS(fp.Navigator.Languages)

	return fmt.Sprintf(`
(function() {
	'use strict';

	// ============================================
	// GHOST BROWSER - ADVANCED FINGERPRINT SPOOF
	// ============================================

	const SPOOF = {
		navigator: {
			hardwareConcurrency: %d,
			deviceMemory: %d,
			platform: '%s',
			vendor: '%s',
			language: '%s',
			languages: Object.freeze([%s]),
			maxTouchPoints: %d,
			webdriver: false,
		},
		screen: {
			width: %d,
			height: %d,
			availWidth: %d,
			availHeight: %d,
			colorDepth: %d,
			pixelDepth: %d,
		},
		window: {
			innerWidth: %d,
			innerHeight: %d,
			outerWidth: %d,
			outerHeight: %d,
			devicePixelRatio: %.2f,
		},
		webgl: {
			vendor: '%s',
			renderer: '%s',
		},
		timezone: {
			name: '%s',
			offset: %d,
		},
		noise: {
			seed: '%s',
			canvas: %.6f,
			audio: %.6f,
		}
	};

	// ============================================
	// 1. NAVIGATOR SPOOFING
	// ============================================
	const navigatorOverrides = {
		hardwareConcurrency: { get: () => SPOOF.navigator.hardwareConcurrency },
		deviceMemory: { get: () => SPOOF.navigator.deviceMemory },
		platform: { get: () => SPOOF.navigator.platform },
		vendor: { get: () => SPOOF.navigator.vendor },
		language: { get: () => SPOOF.navigator.language },
		languages: { get: () => SPOOF.navigator.languages },
		maxTouchPoints: { get: () => SPOOF.navigator.maxTouchPoints },
		webdriver: { get: () => false },
		appVersion: { get: () => navigator.userAgent.replace('Mozilla/', '') },
	};

	for (const [prop, descriptor] of Object.entries(navigatorOverrides)) {
		try {
			Object.defineProperty(Navigator.prototype, prop, { ...descriptor, configurable: true, enumerable: true });
		} catch (e) {}
	}

	// ============================================
	// 2. SCREEN SPOOFING
	// ============================================
	const screenOverrides = {
		width: { get: () => SPOOF.screen.width },
		height: { get: () => SPOOF.screen.height },
		availWidth: { get: () => SPOOF.screen.availWidth },
		availHeight: { get: () => SPOOF.screen.availHeight },
		colorDepth: { get: () => SPOOF.screen.colorDepth },
		pixelDepth: { get: () => SPOOF.screen.pixelDepth },
	};

	for (const [prop, descriptor] of Object.entries(screenOverrides)) {
		try {
			Object.defineProperty(Screen.prototype, prop, { ...descriptor, configurable: true });
		} catch (e) {}
	}

	// Window dimensions
	const windowOverrides = {
		innerWidth: { get: () => SPOOF.window.innerWidth },
		innerHeight: { get: () => SPOOF.window.innerHeight },
		outerWidth: { get: () => SPOOF.window.outerWidth },
		outerHeight: { get: () => SPOOF.window.outerHeight },
		devicePixelRatio: { get: () => SPOOF.window.devicePixelRatio },
		screenX: { get: () => 0 },
		screenY: { get: () => 0 },
		screenLeft: { get: () => 0 },
		screenTop: { get: () => 0 },
	};

	for (const [prop, descriptor] of Object.entries(windowOverrides)) {
		try {
			Object.defineProperty(window, prop, { ...descriptor, configurable: true });
		} catch (e) {}
	}

	// ============================================
	// 3. CSS MEDIA QUERY PROTECTION
	// ============================================
	const originalMatchMedia = window.matchMedia;
	window.matchMedia = function(query) {
		const result = originalMatchMedia.call(this, query);
		
		if (query.includes('device-width') || query.includes('device-height')) {
			return { ...result, matches: true, media: query };
		}
		
		return result;
	};

	// ============================================
	// 4. WEBRTC COMPLETE DISABLE
	// ============================================
	const webrtcBlock = () => {
		Object.defineProperty(window, 'RTCPeerConnection', { value: undefined, writable: false, configurable: false });
		Object.defineProperty(window, 'webkitRTCPeerConnection', { value: undefined, writable: false, configurable: false });
		Object.defineProperty(window, 'mozRTCPeerConnection', { value: undefined, writable: false, configurable: false });
		Object.defineProperty(window, 'RTCSessionDescription', { value: undefined, writable: false, configurable: false });
		Object.defineProperty(window, 'RTCIceCandidate', { value: undefined, writable: false, configurable: false });
		Object.defineProperty(window, 'RTCDataChannel', { value: undefined, writable: false, configurable: false });

		if (navigator.mediaDevices) {
			navigator.mediaDevices.getUserMedia = () => Promise.reject(new Error('Permission denied'));
			navigator.mediaDevices.enumerateDevices = () => Promise.resolve([]);
			navigator.mediaDevices.getDisplayMedia = () => Promise.reject(new Error('Permission denied'));
		}

		navigator.getUserMedia = undefined;
		navigator.webkitGetUserMedia = undefined;
		navigator.mozGetUserMedia = undefined;
	};
	webrtcBlock();

	// ============================================
	// 5. WEBGL SPOOFING
	// ============================================
	const webglHandler = {
		apply(target, thisArg, args) {
			const param = args[0];
			if (param === 37445) return SPOOF.webgl.vendor;
			if (param === 37446) return SPOOF.webgl.renderer;
			if (param === 3379) return 16384;
			if (param === 34024) return 16384;
			return Reflect.apply(target, thisArg, args);
		}
	};

	try {
		WebGLRenderingContext.prototype.getParameter = new Proxy(
			WebGLRenderingContext.prototype.getParameter, webglHandler
		);
	} catch (e) {}

	try {
		if (typeof WebGL2RenderingContext !== 'undefined') {
			WebGL2RenderingContext.prototype.getParameter = new Proxy(
				WebGL2RenderingContext.prototype.getParameter, webglHandler
			);
		}
	} catch (e) {}

	const originalGetExtension = WebGLRenderingContext.prototype.getExtension;
	WebGLRenderingContext.prototype.getExtension = function(name) {
		if (name === 'WEBGL_debug_renderer_info') {
			return { UNMASKED_VENDOR_WEBGL: 37445, UNMASKED_RENDERER_WEBGL: 37446 };
		}
		return originalGetExtension.call(this, name);
	};

	// ============================================
	// 6. CANVAS FINGERPRINT NOISE
	// ============================================
	const seedRandom = (seed) => {
		let h = 0;
		for (let i = 0; i < seed.length; i++) {
			h = Math.imul(31, h) + seed.charCodeAt(i) | 0;
		}
		return () => {
			h = Math.imul(h ^ (h >>> 15), h | 1);
			h ^= h + Math.imul(h ^ (h >>> 7), h | 61);
			return ((h ^ (h >>> 14)) >>> 0) / 4294967296;
		};
	};

	const noiseRng = seedRandom(SPOOF.noise.seed);

	const originalToDataURL = HTMLCanvasElement.prototype.toDataURL;
	const originalToBlob = HTMLCanvasElement.prototype.toBlob;
	const originalGetImageData = CanvasRenderingContext2D.prototype.getImageData;

	const addCanvasNoise = (canvas) => {
		try {
			const ctx = canvas.getContext('2d');
			if (!ctx || canvas.width === 0 || canvas.height === 0) return;

			const w = Math.min(canvas.width, 200);
			const h = Math.min(canvas.height, 200);
			const imageData = originalGetImageData.call(ctx, 0, 0, w, h);
			const data = imageData.data;

			for (let i = 0; i < data.length; i += 4) {
				if (noiseRng() < 0.02) {
					const noise = noiseRng() > 0.5 ? 1 : -1;
					data[i] = Math.max(0, Math.min(255, data[i] + noise));
					data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise));
					data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise));
				}
			}

			ctx.putImageData(imageData, 0, 0);
		} catch (e) {}
	};

	HTMLCanvasElement.prototype.toDataURL = function() {
		addCanvasNoise(this);
		return originalToDataURL.apply(this, arguments);
	};

	HTMLCanvasElement.prototype.toBlob = function(callback, type, quality) {
		addCanvasNoise(this);
		return originalToBlob.call(this, callback, type, quality);
	};

	CanvasRenderingContext2D.prototype.getImageData = function(sx, sy, sw, sh) {
		const imageData = originalGetImageData.call(this, sx, sy, sw, sh);
		const data = imageData.data;
		
		for (let i = 0; i < data.length; i += 4) {
			if (noiseRng() < 0.01) { data[i] ^= 1; }
		}
		
		return imageData;
	};

	// ============================================
	// 7. AUDIO FINGERPRINT NOISE
	// ============================================
	try {
		const originalGetChannelData = AudioBuffer.prototype.getChannelData;
		AudioBuffer.prototype.getChannelData = function(channel) {
			const data = originalGetChannelData.call(this, channel);
			for (let i = 0; i < data.length; i += 100) {
				data[i] += (noiseRng() - 0.5) * SPOOF.noise.audio;
			}
			return data;
		};

		const originalGetFloatFrequencyData = AnalyserNode.prototype.getFloatFrequencyData;
		AnalyserNode.prototype.getFloatFrequencyData = function(array) {
			originalGetFloatFrequencyData.call(this, array);
			for (let i = 0; i < array.length; i += 10) {
				array[i] += (noiseRng() - 0.5) * 0.1;
			}
		};
	} catch (e) {}

	// ============================================
	// 8. TIMEZONE SPOOFING
	// ============================================
	Date.prototype.getTimezoneOffset = function() {
		return SPOOF.timezone.offset;
	};

	const originalDateTimeFormat = Intl.DateTimeFormat;
	Intl.DateTimeFormat = function(locales, options) {
		options = options || {};
		if (!options.timeZone) {
			options.timeZone = SPOOF.timezone.name;
		}
		return new originalDateTimeFormat(locales, options);
	};
	Intl.DateTimeFormat.prototype = originalDateTimeFormat.prototype;

	const originalResolvedOptions = Intl.DateTimeFormat.prototype.resolvedOptions;
	Intl.DateTimeFormat.prototype.resolvedOptions = function() {
		const result = originalResolvedOptions.call(this);
		result.timeZone = SPOOF.timezone.name;
		return result;
	};

	// ============================================
	// 9. REMOVE AUTOMATION FLAGS
	// ============================================
	try { delete Object.getPrototypeOf(navigator).webdriver; } catch (e) {}

	const propsToDelete = [
		'__webdriver_evaluate', '__selenium_evaluate', '__webdriver_script_function',
		'__webdriver_script_func', '__driver_evaluate', '__selenium_unwrapped',
		'_Selenium_IDE_Recorder', '_selenium', 'calledSelenium',
		'$cdc_asdjflasutopfhvcZLmcfl_', '$chrome_asyncScriptInfo',
		'__$webdriverAsyncExecutor', 'domAutomation', 'domAutomationController'
	];

	propsToDelete.forEach(prop => {
		try {
			delete window[prop];
			Object.defineProperty(window, prop, { get: () => undefined });
		} catch (e) {}
	});

	if (window.chrome) {
		window.chrome.runtime = { connect: () => {}, sendMessage: () => {} };
	}

	// ============================================
	// 10. PLUGINS & MIMETYPES SPOOFING
	// ============================================
	try {
		const fakePlugins = [
			{ name: 'PDF Viewer', filename: 'internal-pdf-viewer', description: 'Portable Document Format', length: 1 },
			{ name: 'Chrome PDF Viewer', filename: 'internal-pdf-viewer', description: 'Portable Document Format', length: 1 },
			{ name: 'Chromium PDF Viewer', filename: 'internal-pdf-viewer', description: 'Portable Document Format', length: 1 },
			{ name: 'Microsoft Edge PDF Viewer', filename: 'internal-pdf-viewer', description: 'Portable Document Format', length: 1 },
			{ name: 'WebKit built-in PDF', filename: 'internal-pdf-viewer', description: 'Portable Document Format', length: 1 },
		];

		Object.defineProperty(Navigator.prototype, 'plugins', {
			get: function() {
				const arr = Object.create(PluginArray.prototype);
				fakePlugins.forEach((p, i) => { arr[i] = p; });
				arr.length = fakePlugins.length;
				arr.item = (i) => fakePlugins[i] || null;
				arr.namedItem = (name) => fakePlugins.find(p => p.name === name) || null;
				arr.refresh = () => {};
				return arr;
			},
			configurable: true,
		});

		Object.defineProperty(Navigator.prototype, 'mimeTypes', {
			get: function() {
				const fakeMimes = [
					{ type: 'application/pdf', suffixes: 'pdf', description: 'Portable Document Format' },
					{ type: 'text/pdf', suffixes: 'pdf', description: 'Portable Document Format' },
				];
				const arr = Object.create(MimeTypeArray.prototype);
				fakeMimes.forEach((m, i) => { arr[i] = m; });
				arr.length = fakeMimes.length;
				arr.item = (i) => fakeMimes[i] || null;
				arr.namedItem = (name) => fakeMimes.find(m => m.type === name) || null;
				return arr;
			},
			configurable: true,
		});
	} catch (e) {}

	// ============================================
	// 11. PERMISSIONS & BATTERY API
	// ============================================
	try {
		const originalQuery = Permissions.prototype.query;
		Permissions.prototype.query = function(descriptor) {
			if (descriptor.name === 'notifications') {
				return Promise.resolve({ state: 'prompt', onchange: null });
			}
			return originalQuery.call(this, descriptor);
		};
	} catch (e) {}

	try {
		navigator.getBattery = () => Promise.resolve({
			charging: true,
			chargingTime: 0,
			dischargingTime: Infinity,
			level: 1.0,
			addEventListener: () => {},
			removeEventListener: () => {},
		});
	} catch (e) {}

	// ============================================
	// DONE
	// ============================================
	console.log('[Ghost Browser] âœ… Fingerprint spoofing active');
	console.log('[Ghost Browser] Profile: CPU=' + SPOOF.navigator.hardwareConcurrency + 
		', RAM=' + SPOOF.navigator.deviceMemory + 'GB, Screen=' + SPOOF.screen.width + 'x' + SPOOF.screen.height);
})();
`,
		// Navigator
		fp.Navigator.HardwareConcurrency,
		fp.Navigator.DeviceMemory,
		fp.Navigator.Platform,
		fp.Navigator.Vendor,
		fp.Navigator.Language,
		languagesJS,
		fp.Navigator.MaxTouchPoints,
		// Screen
		fp.Screen.Width,
		fp.Screen.Height,
		fp.Screen.AvailWidth,
		fp.Screen.AvailHeight,
		fp.Screen.ColorDepth,
		fp.Screen.PixelDepth,
		// Window
		fp.Screen.Width,
		fp.Screen.Height-100,
		fp.Screen.Width,
		fp.Screen.Height,
		fp.Screen.PixelRatio,
		// WebGL
		fp.WebGL.Vendor,
		fp.WebGL.Renderer,
		// Timezone
		fp.Timezone.Timezone,
		fp.Timezone.TimezoneOffset,
		// Noise
		noiseSeed,
		fp.Canvas.Noise,
		fp.Audio.Noise,
	)
}

func generateNoiseSeed() string {
	bytes := make([]byte, 16)
	rand.Read(bytes)
	return hex.EncodeToString(bytes)
}

func formatLanguagesJS(languages []string) string {
	quoted := make([]string, len(languages))
	for i, lang := range languages {
		quoted[i] = fmt.Sprintf("'%s'", lang)
	}
	return strings.Join(quoted, ", ")
}
